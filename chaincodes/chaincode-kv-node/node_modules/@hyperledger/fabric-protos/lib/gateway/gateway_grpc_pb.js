// GENERATED CODE -- DO NOT EDIT!

// Original file comments:
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0
//
'use strict';
var grpc = require('@grpc/grpc-js');
var gateway_gateway_pb = require('../gateway/gateway_pb.js');
var peer_chaincode_event_pb = require('../peer/chaincode_event_pb.js');
var peer_proposal_pb = require('../peer/proposal_pb.js');
var peer_proposal_response_pb = require('../peer/proposal_response_pb.js');
var peer_transaction_pb = require('../peer/transaction_pb.js');
var common_common_pb = require('../common/common_pb.js');
var orderer_ab_pb = require('../orderer/ab_pb.js');

function serialize_gateway_ChaincodeEventsResponse(arg) {
  if (!(arg instanceof gateway_gateway_pb.ChaincodeEventsResponse)) {
    throw new Error('Expected argument of type gateway.ChaincodeEventsResponse');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_gateway_ChaincodeEventsResponse(buffer_arg) {
  return gateway_gateway_pb.ChaincodeEventsResponse.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_gateway_CommitStatusResponse(arg) {
  if (!(arg instanceof gateway_gateway_pb.CommitStatusResponse)) {
    throw new Error('Expected argument of type gateway.CommitStatusResponse');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_gateway_CommitStatusResponse(buffer_arg) {
  return gateway_gateway_pb.CommitStatusResponse.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_gateway_EndorseRequest(arg) {
  if (!(arg instanceof gateway_gateway_pb.EndorseRequest)) {
    throw new Error('Expected argument of type gateway.EndorseRequest');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_gateway_EndorseRequest(buffer_arg) {
  return gateway_gateway_pb.EndorseRequest.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_gateway_EndorseResponse(arg) {
  if (!(arg instanceof gateway_gateway_pb.EndorseResponse)) {
    throw new Error('Expected argument of type gateway.EndorseResponse');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_gateway_EndorseResponse(buffer_arg) {
  return gateway_gateway_pb.EndorseResponse.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_gateway_EvaluateRequest(arg) {
  if (!(arg instanceof gateway_gateway_pb.EvaluateRequest)) {
    throw new Error('Expected argument of type gateway.EvaluateRequest');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_gateway_EvaluateRequest(buffer_arg) {
  return gateway_gateway_pb.EvaluateRequest.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_gateway_EvaluateResponse(arg) {
  if (!(arg instanceof gateway_gateway_pb.EvaluateResponse)) {
    throw new Error('Expected argument of type gateway.EvaluateResponse');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_gateway_EvaluateResponse(buffer_arg) {
  return gateway_gateway_pb.EvaluateResponse.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_gateway_SignedChaincodeEventsRequest(arg) {
  if (!(arg instanceof gateway_gateway_pb.SignedChaincodeEventsRequest)) {
    throw new Error('Expected argument of type gateway.SignedChaincodeEventsRequest');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_gateway_SignedChaincodeEventsRequest(buffer_arg) {
  return gateway_gateway_pb.SignedChaincodeEventsRequest.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_gateway_SignedCommitStatusRequest(arg) {
  if (!(arg instanceof gateway_gateway_pb.SignedCommitStatusRequest)) {
    throw new Error('Expected argument of type gateway.SignedCommitStatusRequest');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_gateway_SignedCommitStatusRequest(buffer_arg) {
  return gateway_gateway_pb.SignedCommitStatusRequest.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_gateway_SubmitRequest(arg) {
  if (!(arg instanceof gateway_gateway_pb.SubmitRequest)) {
    throw new Error('Expected argument of type gateway.SubmitRequest');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_gateway_SubmitRequest(buffer_arg) {
  return gateway_gateway_pb.SubmitRequest.deserializeBinary(new Uint8Array(buffer_arg));
}

function serialize_gateway_SubmitResponse(arg) {
  if (!(arg instanceof gateway_gateway_pb.SubmitResponse)) {
    throw new Error('Expected argument of type gateway.SubmitResponse');
  }
  return Buffer.from(arg.serializeBinary());
}

function deserialize_gateway_SubmitResponse(buffer_arg) {
  return gateway_gateway_pb.SubmitResponse.deserializeBinary(new Uint8Array(buffer_arg));
}


// The Gateway API for evaluating and submitting transactions via the gateway.
// Transaction evaluation (query) requires the invocation of the Evaluate service
// Transaction submission (ledger updates) is a two step process invoking Endorse
// followed by Submit. A third step, invoking CommitStatus, is required if the
// clients wish to wait for a Transaction to be committed.
// The proposal and transaction must be signed by the client before each step.
var GatewayService = exports.GatewayService = {
  // The Endorse service passes a proposed transaction to the gateway in order to
// obtain sufficient endorsement.
// The gateway will determine the endorsement plan for the requested chaincode and
// forward to the appropriate peers for endorsement. It will return to the client a
// prepared transaction in the form of an Envelope message as defined
// in common/common.proto. The client must sign the contents of this envelope
// before invoking the Submit service.
endorse: {
    path: '/gateway.Gateway/Endorse',
    requestStream: false,
    responseStream: false,
    requestType: gateway_gateway_pb.EndorseRequest,
    responseType: gateway_gateway_pb.EndorseResponse,
    requestSerialize: serialize_gateway_EndorseRequest,
    requestDeserialize: deserialize_gateway_EndorseRequest,
    responseSerialize: serialize_gateway_EndorseResponse,
    responseDeserialize: deserialize_gateway_EndorseResponse,
  },
  // The Submit service will process the prepared transaction returned from Endorse service
// once it has been signed by the client. It will wait for the transaction to be submitted to the
// ordering service but the client must invoke the CommitStatus service to wait for the transaction
// to be committed.
submit: {
    path: '/gateway.Gateway/Submit',
    requestStream: false,
    responseStream: false,
    requestType: gateway_gateway_pb.SubmitRequest,
    responseType: gateway_gateway_pb.SubmitResponse,
    requestSerialize: serialize_gateway_SubmitRequest,
    requestDeserialize: deserialize_gateway_SubmitRequest,
    responseSerialize: serialize_gateway_SubmitResponse,
    responseDeserialize: deserialize_gateway_SubmitResponse,
  },
  // The CommitStatus service will indicate whether a prepared transaction previously submitted to
// the Submit sevice has been committed. It will wait for the commit to occur if it hasnâ€™t already
// committed.
commitStatus: {
    path: '/gateway.Gateway/CommitStatus',
    requestStream: false,
    responseStream: false,
    requestType: gateway_gateway_pb.SignedCommitStatusRequest,
    responseType: gateway_gateway_pb.CommitStatusResponse,
    requestSerialize: serialize_gateway_SignedCommitStatusRequest,
    requestDeserialize: deserialize_gateway_SignedCommitStatusRequest,
    responseSerialize: serialize_gateway_CommitStatusResponse,
    responseDeserialize: deserialize_gateway_CommitStatusResponse,
  },
  // The Evaluate service passes a proposed transaction to the gateway in order to invoke the
// transaction function and return the result to the client. No ledger updates are made.
// The gateway will select an appropriate peer to query based on block height and load.
evaluate: {
    path: '/gateway.Gateway/Evaluate',
    requestStream: false,
    responseStream: false,
    requestType: gateway_gateway_pb.EvaluateRequest,
    responseType: gateway_gateway_pb.EvaluateResponse,
    requestSerialize: serialize_gateway_EvaluateRequest,
    requestDeserialize: deserialize_gateway_EvaluateRequest,
    responseSerialize: serialize_gateway_EvaluateResponse,
    responseDeserialize: deserialize_gateway_EvaluateResponse,
  },
  // The ChaincodeEvents service supplies a stream of responses, each containing all the events emitted by the
// requested chaincode for a specific block. The streamed responses are ordered by ascending block number. Responses
// are only returned for blocks that contain the requested events, while blocks not containing any of the requested
// events are skipped.
chaincodeEvents: {
    path: '/gateway.Gateway/ChaincodeEvents',
    requestStream: false,
    responseStream: true,
    requestType: gateway_gateway_pb.SignedChaincodeEventsRequest,
    responseType: gateway_gateway_pb.ChaincodeEventsResponse,
    requestSerialize: serialize_gateway_SignedChaincodeEventsRequest,
    requestDeserialize: deserialize_gateway_SignedChaincodeEventsRequest,
    responseSerialize: serialize_gateway_ChaincodeEventsResponse,
    responseDeserialize: deserialize_gateway_ChaincodeEventsResponse,
  },
};

exports.GatewayClient = grpc.makeGenericClientConstructor(GatewayService);
